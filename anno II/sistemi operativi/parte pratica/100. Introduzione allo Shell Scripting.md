## Shortcuts utili
- ```Ctrl + S```: sospende il focus alla shell;
- ```Ctrl + Q```: riattiva il focus;
- ```Ctrl + C```: interrompe un'istruzione;
- ```Ctrl + D``` : end-of-line;
## Comandi per ottenere informazioni su altri comandi
- ```man comando```:  mostra il manuale;
- ```info comando```: mostra la documentazione;
- ```apropos keyword```: mostra comandi simili o correlati alla parola specificata;
## Nozioni di base
Una raccolta di nozioni fondamentali per comprendere il contesto in cui lavoreremo.
### Cos'è la Shell
La shell è un programma che permette all'utente di lavorare con le primitive esposte dell'OS, programmabile mediante script in un apposito linguaggio (il **bash**).
### Cos'è lo Shell Scripting
Lo Shell Scripting consente di automatizzare sequenze di comandi nativi dell'OS, permettendo di gestire sistemi e di automatizzare task quotidiane.

> Lavoreremo con i comandi della shell dei sistemi Unix, come Linux e MacOS.
### La struttura dei comandi
Tutti i comandi UNIX seguono la stessa struttura:
```bash
comando [opzioni] [args]
```
dove le opzioni sono precedute da:
- -- se nella loro forma **verbose** (per esteso), come --yes;
- \- se nella loro forma abbreviata, come -y;

mentre gli argomenti si usano invece per passare eventuali dati/risorse al comando scelto.
## Il file system
Il file system dei sistemi UNIX può essere visto come un albero, dove la root equivale all'omonima cartella (**/**), i nodi alle varie sotto directory e le foglie ai file.

Per specificare una posizione all'interno di esso si usano i path, che possono essere di due tipi:
- **assoluti**, ovvero che partono dalla root;
- **relativi**, ovvero che partono dalla directory corrente;

Nei sistemi UNIX il file system segue una gerarchia standard:
- ```/bin``` contiene i principali comandi del terminale, spesso file binary compilati;
- ```/sbin``` contiene i comandi di sicurezza (o amministrazione), anch'essi in formato binario;
- ```/dev``` contiene i file per le periferiche connesse, in un apposito formato;
- ```/etc``` contiene i file di configurazione dell'OS e delle applicazioni installate;
- ```/home``` contiene la home directory dei vari utenti;
- ```/lib``` contiene le librerie condivise dai vari programmi;
- ```/tmp``` contiene i file temporanei;
- ```/var``` contiene dei dati di sistema come i log, dati delle applicazioni, e simili;
- ```/usr``` contiene i programmi installati per il singolo utente, come potrebbe essere **python**.

Nella shell, si può indicare la propria home come **~**, permettendo di scrivere (supponendo che il proprio username nel sistema sia "studente")
```bash
~/documenti
```
invece che dover specificare
```bash
/home/studente/documenti
```

Ogni file ha dei permessi di lettura (**r**), scrittura (**w**) ed esecuzione (**x**) associati ad esso, che possono variare in base al gruppo a cui l'utente che cerco di interagire con essi fa parte.
In generale, ogni file ha:
- un **owner**;
- un **gruppo**;
- nove bit di **permessi** divisi per gruppo utente:
	- il gruppo **user** (proprietario);
	- il gruppo **group**;
	- il gruppo **others** (per gli utenti generici);
### Navigare il file system
- ```pwd``` stampa la directory corrente;
- ```cd directory``` si sposta nella dir specificata;
- ```mkdir directory``` crea la dir specificata;
- ```rmdir directory``` rimuove la directory specificata, se vuota;
	- ```-r``` rimuove la directory specificata e tutti i dati al suo interno;
- ```ls``` mostra il contenuto della directory corrente;
	- ```- a``` mostra anche i file nascosti;
	- ```- l``` mostra un formato più verbose;
	- ```- g``` mostra anche i dettagli dei permessi per gruppo dei dati mostrati;
	- ```ls directory``` mostra il contenuto della dir specificata;
### Gestire i file
- ```rm file``` cancella il file specificato;
- ```cp origine destinazione``` copia il file specificato al path ```origine``` in quello ```destinazione```;
- ```mv origine destinazione``` fa la stessa cosa di ```cp```, ma spostando il file anziché copiarlo;
- ```ln file hardlink``` crea un hard link del file specificato;
- ```ln -s file symlink``` crea un link simbolico del file specificato;
- ```more/less file``` visualizza un file pagina per pagina;

> Un file non può essere cancellato finché esistono hard links.
> Un link simbolico invece punta al nome di un file e diventa invalido se il file originale viene cancellato.
### Modificare i permessi di un file
Per modificare i permessi associati ad un file o ad una directory, si può optare per due vie.
Esiste il metodo relativo:
```bash
chmod u+x path    # aggiunge esecuzione per user al path specificato
chmod ug+rw path  # aggiunge read e write per user e group
chmod o -rwx path # rimuove tutti i permessi ad others
```
ed esiste quello assoluto (o **ottale**):
```bash
chmod 755 path   # rwxr-xr-rx
chmod 644 path   # rw-r-r
```
Nel metodo ottale, ad ogni permesso equivale un numero:
```
r = 4
w = 2
x = 1
```
Nel comando ```chmod``` ogni unità specifica un permesso per un determinato gruppo.
Nel primo esempio (```chmod 755 path```) quindi stiamo fornendo:
- a ```user``` i permessi $4 + 2 + 1$, quindi tutti e tre;
- a ```user``` e ```group``` i permessi $4 + 1$, quindi ```r``` e ```x```;
- ad ```others``` i permessi $4 + 1$, quindi nuovamente ```r``` e ```x```;
### Modificare le proprietà di un file
- ```chown nuovo_nome path``` cambia il proprietario;
- ```chgrp nuovo_gruppo path``` cambia il gruppo;
- ```groups path``` mostra i gruppi associati;
## I processi
Ogni processo possiede degli attributi.
- **PID**: un identificatore;
- **PPID**: il PID del padre;
- **nice number**: il livello di priorità;
- **TTY**: il terminale associato;
- **user/group id**: il proprietario.
### Gestione dei processi
- ```ps``` mostra tutti i processi;
	- ```ps alx``` mostra anche le proprietà dei processi;
- ```nice -n nuova_prio comando``` esegue un processo modificandone la priorità;
- ```renice +5 -p pid``` cambia la priorità di un processo;
- ```kill pid``` termina un processo;
- ```kill -9 pid``` termina forzatamente un processo;
### Gestione dei job
- ```comando &``` esegue in un altro terminale un comando, in background;
- ```Ctrl + Z``` ferma il processo in foreground;
- ```jobs``` elenca tutti i processi in background;
- ```fg %n``` porta in foreground il job ```n```;
- ```bg %n``` porta in background il job ```n```;
## Nozioni sulle shell
Esistono diversi tipi di shell, ma quella classica di Linux è la Bash (Bourne Again Shell).

La shell supporta l'uso di metacaratteri:
- ```>, >>, <``` redirezionano l'I/O;
- ```|``` indica una pipeline;
- ``` $a = `comando` ``` salva l'output di ```comando``` in ```a``` (command substitution);
- ```;``` esecuzione sequenziale;
- ```||```,```&&``` esecuzione condizionale;
- ```(...)``` raggruppamento comandi;
- ```&``` esecuzione in background;
- ```""```,```''``` quoting;
- ```#``` commento;
- ```$``` utilizzo (espansione) variabile;
- ```\``` escaping caratteri speciali;
- ```comando << text``` aggiunge ```text``` al termine dell'esecuzione di ```comando``` (here document);

### Redirezione I/O
Ogni processo ha tre stream: **stdin**, **stdout** e **stderr**. Questi si possono redirezionare mediante appositi operatori:
```bash
ls > lista.txt       # sovrascrive il contenuto di lista.txt con l'output di ls
ls >> lista.txt      # appenda l'output di ls al contenuto di lista.txt
mail user < info.txt # usa info.txt come input per la mail
comando >& /dev/null # redirige stdout e stderr
```

### Pipeline
Le pipe collegano l'output di un comando all'input di un altro:
```bash
ls | wc -w                  # conta i file nella directory
who | tee utenti.txt | sort # salva su file ed ordina gli utenti
```
### Command Substitution
Alla base i command substitution (indicati con ``` ` ` ```) si comportano in maniera simile all'istruzione ```eval``` di python: permettono di eseguire codice e "rimpiazzare" il comando con l'output di questo (ma in maniera più sicura). Ad esempio:
```bash
data=`(date)`
echo "Oggi è ${data}"
```
### Sequenze di comandi
Per eseguire dei comandi in sequenza, si usa l'operatore ```;```:
```bash
date; pwd; ls
```
Per eseguire un comando in base all'esito di un altro comando, si usano ```||``` e ```&&```:
```bash
gcc prog.c && ./a.out       # esegue a.out solo se gcc ha successo
gcc prog.c || echo "errore" # stampa errore solo se gcc fallisce
```
Per eseguire un comando in background, si usa ```&```:
```bash
# cerca tutti i file chiamati passwd partendo dalla root e li inserisce
# assieme ad eventuali errori nel file "risultati.txt", in background
find /-name passwd -print &> risultati.txt &
```
### Quoting
Gli apici singoli ```'``` disabilitano tutti i metacaratteri, mentre i doppi apici ```"``` disabilitano solamente le wildcards:
```bash
echo "Nome: $USER, Data: `date`" # espande variabili e comandi
echo 'Nome: $USER, Data: `date`' # stampa letteralmente
```

> Le wildcards (i caratteri per le regex) si possono usare in Bash.
### Variabili
Esistono due tipi di variabile: quelle **locali** (non ereditate dalla subshell) e quelle **di ambiente** (che invece vengono ereditate).
```bash
nome="Andrea"   # assegnazione (senza spazi)
echo ${nome}    # stampa il valore della variabile
export nome     # rende la variabile d'ambiente
```
Esistono alcune variabili predefinite, tra cui le piu importanti:
- ```$HOME```: la home directory;
- ```$PATH```: percorsi di ricerca comandi;
- ```$USER```: il proprio nome utente;
- ```$SHELL```: la shell attuale;
### Here Document
Permette di fornire input multi-linea ad un comando. Ad esempio:
```bash
mail $USER << FINE
Ciao,
spero che tu stia bene.
Saluti
FINE
```

> ```<<``` espande le variabili, mentre ```<</``` non le espande. 
## Shell Scripting
Uno script è una sequenza di comandi salvata su file che, per essere eseguita in una subshell, deve avere il permesso di **execute**.

Gli script di Bash devono specificare nella prima riga il tipo di shell che deve interpretare lo script (**shebang**). Ad esempio:
```bash
#!/bin/bash
```

Gli script di Bash posseggono delle variabili built-in:
- ```$$``` il PID della Shell;
- ```$0``` il nome dello script;
- ```$1, $2, ... $9``` argomenti posizionali;
- ```$10``` tutti gli argomenti dopo il nono;
- ```$*``` tutti gli argomenti;
- ```$#``` numero di argomenti;
- ```$?``` exit status dell'ultimo comando eseguito.