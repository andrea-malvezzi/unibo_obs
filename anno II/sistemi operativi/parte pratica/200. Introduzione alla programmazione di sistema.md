## Introduzione
Normalmente quando si scrive un programma (ad esempio in **C**) con un ```main()``` e lo si compila, si lascia fare il linking a tool come **gcc**. Se invece si provasse ad effettuare il linking manuale tramite comandi come ```ld```, si otterrebbe un errore in quanto mancherebbe il simbolo ```_start```, ovvero un codice fornito dalla libreria standard del linguaggio (in questo caso dalla libreria standard di **C**) per prepare l'ambiente di esecuzione.

Nello specifico, al lancio del processo l'OS cerca il simbolo ```_start```, prepara l'ambiente dopo averlo trovato, esegue il ```main()``` e, quando questo ritorna, chiama la **system call** ```exit``` per terminare il processo.

Le **system calls** sono dei meccanismi esposti dall'OS che i linguaggi di programmazione possono usare per richiedere l'uso di risorse al kernel, in modo da astrarre la gestione di queste ultime.

Una situazione classica dove si programma in assenza di system calls è quella dei microcontrollori: qui invece di utilizzare un linguaggio fatto e finito, si lavora a basso livello, gestendo manualmente la memoria hardware senza appoggiarsi ad un OS mediante system calls. Ad esempio:
```C
#define DDRC  (*(volatile uint8_t *) 0x27) // registro fisico correlato ad un pin
#define PORTC (*(volatile uint8_t *) 0x28) // PORTC - controlla on/off del pin

DDRC  |= 1 << 5;  // pin PC5 diventa out
PORTC ^= 1 << 5;  // toggle (on/off) del pin
```
Questo codice accende o spegne un led su un microcontroller senza utilizzare librerie o system call, manipolando direttamente la memoria hardware. 
## System Calls per la gestione processi
Esistono svariate system calls che i programmi usano per comunicare con l'OS, ma tra tutte ricordiamo le più importanti, ovvero $\dots$
### fork()
System call usata per duplicare il processo corrente, restituendo:
- il **PID** del figlio al padre (quindi un valore $\not=0 \rightarrow$ ```true```);
- $0$ al figlio (quindi ```false```).

AD esempio il seguente codice:
```c
if (fork())
	printf("ho ricevuto un PID dalla fork (quindi sono il padre)!\n");
else
	printf("non ho ricevuto un PID dalla fork (quindi sono il figlio)!\n");
```
stamperà sia il primo che il secondo caso (in quest'ordine), in quanto il processo verrà sdoppiato.
### $\_$exit()
System call usata per terminare un processo ritornando un **exit status** che la shell può leggere tramite il comando ```$?```. Ad esempio, potremmo avere un programma **C** che accetti input dall'utente e che in base alla parità di esso ritorni $1$ o $0$:
```c
// nome file: test.c
int n;
scanf("%d", &n);

if (n % 2 == 1)
	_exit(1)

return 0;
```
e poi da shell potremmo scrivere, per saperne l'output:
```bash
gcc -o test test.c
./test
echo $? # 1 se dispari e 0 se pari
```
### sleep()
System call usata per fermare il programma per $n$ secondi. Utile quando si vuole vedere l'ordine di esecuzione di un programma:
```c
if (fork()) {
	printf("parent %d\n", getpid());
} else {
	sleep(2);  // aspetta 2 secondi
	printf("child %d son of %d\n", getpid(), getppid());  // getppid => pid padre
}
```
### wait()
I figli che terminano prima del processo padre diventano **zombie**: sono cioè presenti in memoria ma senza un uso effettivo. Questo avviene perché una volta terminati, il loro exit status non è ancora stato "raccolto" dal processo padre. Spesso i processi in questo stato per essere cancellati devono attendere di venire raccolti dal garbage collector, al termine del programma.

La system call ```wait()``` previene questo "limbo", bloccando il padre fino a quando il figlio non termina. Se il figlio è già terminato, allora ne **raccoglie** (non legge, raccoglie) lo status e prosegue normalmente.
#### WEXITSTATUS e WIFEXITED
Queste non sono system calls ma bensì delle macro che vengono spesso usate in combo con la ```wait()``` per gestire correttamente i processi figli ed evitare zombie, ad esempio nella maniera seguente:
```c
int main() {
	if (fork() == 0) { // FIGLIO
		printf("Figlio: esco con status 42\n");
		_exit(42);
	}
	
	// PADRE
	int status;
	wait(&status);  // aspetto che il figlio termini
	
	// se il figlio ha terminato senza problemi
	if (WIFEXITED(status)) {
		// scrivo l'exit status del figlio, raccolto tramite wait
		printf("Exit status del figlio: %d\n", WEXITSTATUS(status));
	}
	
	return 0;
}
```
Questo schema serve perché l'exit status di un processo non è un semplice intero, ma bensì un intero codificato per contenere una collezione di dati, tra cui anche il codice ritornato.

Nello specifico quindi:
- ```WIFEXITED``` controlla che il processo sia terminato normalmente (ovvero mediante ```exit```, ```_exit``` o ```return``` dal main) o se mediante errore;
- ```WEXITSTATUS``` estrae i bit della variabile ```status``` per estrapolare solamente il valore ritornato da eventuali statement per terminare il processo.
### execve()
System call che sostituisce completamente il codice, lo stack ed i dati di un processo con un altro (mantenendo tuttavia il PID). Ad esempio:
```c
char *exec_argv[] = {
	"ls", "-l", "/", NULL
};
execve("/bin/ls", exec_argv, NULL); // sostituisce il resto con: ls -l / 
printf("Non raggiungerai mai questa riga.\n");
```
### init
```init``` non è una system call ma bensì un processo che viene iniziato automaticamente all'avvio del sistema. Esso è composto da un ciclo infinito che continua a chiamare ```wait``` per raccogliere eventuali processi orfani ed evitare che rimangano zombie per sempre.

## Come fa la shell ad eseguire un comando?
Quando si digita ```ls -l /``` nella shell:
1. La Shell esegue una ```fork()``` e crea un processo figlio;
2. il processo figlio esegue ```execve("/bin/ls", ...)```, diventando ```ls```;
3. il padre esegue una ```wait()``` ed aspetta che ```ls``` termini;
4. il padre legge l'exit status del figlio con ```WEXITSTATUS()```;
5. la Shell torna disponibile per il prossimo comando.

